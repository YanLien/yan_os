# 使用Rust编写操作系统
## （一）：独立式可执行程序

禁用标准库自动引用（automatic inclusion）。使用`no_std`属性可以实现这一点
`panic_handler`属性被用于定义一个函数；在程序`panic`时，这个函数将会被调用。
类型为PanicInfo的参数包含了panic发生的文件名、代码行数和可选的错误信息。这个函数从不返回，所以他被标记为发散函数（diverging function）。发散函数的返回类型称作Never类型（"never" type），记为!。
语言项是一些编译器需求的特殊函数或类型。
eh_personality语言项标记的函数，将被用于实现栈展开（stack unwinding）。在使用标准库的情况下，当panic发生时，Rust将使用栈展开，来运行在栈上活跃的所有变量的析构函数（destructor）——这确保了所有使用的内存都被释放，允许调用程序的父进程（parent thread）捕获panic，处理并继续运行。但是，栈展开是一个复杂的过程，通常需要依赖于操作系统的库；所以我们不在自己编写的操作系统中使用它。
在其它一些情况下，栈展开不是迫切需求的功能；因此，Rust提供了在panic时中止（abort on panic）的选项。这个选项能禁用栈展开相关的标志信息生成，也因此能缩小生成的二进制程序的长度。最简单的打开方式是把下面的几行设置代码加入我们的Cargo.toml：
``` Rust
[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```
这些选项能将dev配置（dev profile）和release配置（release profile）的panic策略设为abort。dev配置适用于cargo build，而release配置适用于cargo build --release。现在编译器应该不再要求我们提供eh_personality语言项实现。
这里，我们的程序遗失了start语言项，它将定义一个程序的入口点
重写入口点。要告诉Rust编译器我们不使用预定义的入口点，我们可以添加#![no_main]属性。
使用no_mangle标记这个函数，来对它禁用名称重整（name mangling）——这确保Rust编译器输出一个名为_start的函数；否则，编译器可能最终生成名为_ZN3blog_os4_start7hb173fedf945531caE的函数，无法让链接器正确辨别。

为了描述不同的环境，Rust使用一个称为目标三元组（target triple）的字符串。要查看当前系统的目标三元组，我们可以运行rustc --version --verbose。

found duplicate lang item `panic_impl` the lang item is first defined in crate `std` (which `test` depends on)rustc(E0152)的解决方法：
（1）、定义panic还是会提示已存在，加上#[cfg(not(test))]即可

## （二）：最小化内核

### BIOS启动

BIOS启动的过程
当电脑启动时，主板上特殊的闪存中存储的BIOS固件将被加载。BIOS固件将会上电自检、初始化硬件，然后它将寻找一个可引导的存储介质。如果找到了，那电脑的控制权将被转交给引导程序（bootloader）：一段存储在存储介质的开头的、512字节长度的程序片段。大多数的引导程序长度都大于512字节——所以通常情况下，引导程序都被切分为一段优先启动、长度不超过512字节、存储在介质开头的第一阶段引导程序（first stage bootloader），和一段随后由其加载的、长度可能较长、存储在其它位置的第二阶段引导程序（second stage bootloader）。
引导程序必须决定内核的位置，并将内核加载到内存。引导程序还需要将CPU从16位的实模式，先切换到32位的保护模式（protected mode），最终切换到64位的长模式（long mode）：此时，所有的64位寄存器和整个主内存（main memory）才能被访问。引导程序的第三个作用，是从BIOS查询特定的信息，并将其传递到内核；如查询和传递内存映射表（memory map）。

通过--target参数，cargo支持不同的目标系统。这个目标系统可以使用一个目标三元组（target triple）来描述，它描述了CPU架构、平台供应者、操作系统和应用程序二进制接口（Application Binary Interface, ABI）。

## （三）：VGA字符模式

VGA字符模式（VGA text mode）是打印字符到屏幕的一种简单方式。

为了确保ColorCode和u8有完全相同的内存布局，我们添加repr(transparent)标记。

在内存布局层面，Rust并不保证按顺序布局成员变量。因此，我们需要使用#[repr(C)]标记结构体；这将按C语言约定的顺序布局它的成员变量，让我们能正确地映射内存片段。内存映射: 通过内存地址0xb8000访问了[VGA文本缓冲区]

端口映射I/O使用独立的I/O总线来进行通信。每个外围设备都有一个或数个端口号。CPU采用了特殊的`in`和`out`指令来和端口通信，这些指令要求一个端口号和一个字节的数据作为参数。`isa-debug-exit`设备使用的就是端口映射I/O。其中，`iobase`参数指定了设备对应的端口地址（在x86中，0xf4是一个通常未被使用的端口），而`iosize`则指定了端口的大小（0x04代表4字节）。

## （四）内核测试

Rust支持通过使用不稳定的自定义测试框架（custom_test_frameworks） 功能来替换默认的测试框架。该功能不需要额外的库，因此在 #[no_std]环境中它也可以工作。它的工作原理是收集所有标注了 #[test_case]属性的函数，然后将这个测试函数的列表作为参数传递给用户指定的runner函数。因此，它实现了对测试过程的最大控制。

Rust 有一个特殊的属性，#[cfg]，它允许您根据传递给编译器的标志来编译代码。

在x86平台上，CPU和外围硬件通信通常有两种方式，内存映射I/O和端口映射I/O。

所有的集成测试都是它们自己的可执行文件，并且与我们的main.rs完全独立。这也就意味着每个测试都需要定义它们自己的函数入口点。

因为I/O端口的写入操作通常会导致一些不可预知的行为。

cargo test会将所有非0的错误码都视为测试失败。

串口非常易于编程，QEMU可以将通过串口发送的数据重定向到宿主机的标准输出或是文件中。

uart_16550 crate包含了一个代表UART寄存器的SerialPort结构体

无约束测试
对于那些只有单个测试函数的集成测试而言(例如我们的should_panic测试)，其实并不需要测试运行器。对于这种情况，我们可以完全禁用测试运行器，直接在_start函数中直接运行我们的测试。这里的关键就是在Cargo.toml中为测试禁用 harness flag，这个标志（flag）定义了是否将测试运行器用于集成测试中。如果该标志位被设置为false，那么默认的测试运行器和自定义的测试运行器功能都将被禁用，这样一来该测试就可以像一个普通的可执行程序一样运行了。

## （五）CPU异常

[CPU异常](https://wiki.osdev.org/Exceptions)
为了捕获并处理CPU异常，我们需要建立所谓的中断描述符表（interrupt descriptor table，IDT)。在IDT中，我们可以为每种异常指定一个处理函数。

|Type|	Name|	Description|
|----|--------|---------|
|u16|	函数指针[0:15]	|处理函数（handler function)指针的低16位|
|u16|	GDT 选择子|	global descriptor table 代码段的选择子|
|u16|	选项参数	|参见下文|
|u16|	函数指针[16:31]|	处理函数（handler function)指针的中间16位|
|u32|	函数指针[32:63]|	处理函数（handler function)指针剩下的32位|
|u32|	保留位	|
选项参数必须是下面的结构：

|Bits|	Name	|Description|
|--|-------|--|
|0-2|	中断栈表索引	|0: 不切换栈, 1-7:当处理函数被调用时，切换到中断栈表（Interrupt Stack Table）的第n个栈|
|3-7|	保留位	|
|8|	0: 中断门, 1: 陷阱门|如果这个bit被设置为0，处理函数被调用的时候，中断会被禁用。|
|9-11|	必须为1	|
|12	|必须为0	|
|13‑14	|特权等级描述符 (DPL)|	允许调用该处理函数的最小特权等级。|
|15	|Present	|

每个异常都拥有提前约定好的IDT索引。

当异常发生时，CPU大致遵循下面的流程：
1. 将一些寄存器的内容压入栈中，包括当前指令的指针和RFLAGS寄存器的内容（我们会在文章的后续部分用到这些值）。
2. 读取中断描述符表（IDT）中对应的条目。例如：缺页错误发生时，CPU会读取IDT的第十四个条目。
3. 检查这个条目是否存在，如果没有则升级为双重错误（double fault)。
4. 如果条目是一个中断门（第40个bit没有被设置为1），则禁用硬件中断。
5. 装载指定的GDT 选择子到CS段。
6. 跳转到指定的处理函数。

在函数调用的过程中，preserved寄存器的值必须保持不变。所以，被调用的函数（callee）必须保证会在返回以前会主动复原这些寄存器的原始值，才可以修改这些寄存器的值。因此，这些寄存器被称为被调用者保存寄存器（callee-saved，译者注：也就是AKA非易失性寄存器）。通行的模式是在函数的开始保存这些寄存器的值到函数栈中，并在函数马上返回的时候复原他们。

相比之下，被调用的函数（callee）可以无约束地修改 scratch寄存器。如果调用者函数希望在函数调用的过程中保留 scratch寄存器的值，它需要在调用函数之前备份和复原 scratch寄存器的值（例如将这些值压入栈中）。所以，这些寄存器被称为调用者寄存器（caller-saved，译者注：也就是AKA易失性寄存器）。

x86-interrupt调用约定恰恰能够保证所有寄存器会在函数调用结束以前复原到原始值。

在x86_64架构中，C语言调用约定明确规定了下面的 preserved and scratch 寄存器：

|preserved寄存器|scratch寄存器|
|---|---|
|rbp, rbx, rsp, r12, r13, r14, r15|rax, rcx, rdx, rsi, rdi, r8, r9, r10, r11|
|callee-saved|caller-saved|

在异常发生的时候，CPU会执行以下步骤：
1. 对齐栈指针：中断可以发生在任何指令的执行过程中，栈指针自然也可能是任何值。然而，一些CPU指令集（e.g. 一些SSE指令集）需要栈指针在16字节边界上对齐，因此CPU会在中断之后靠右对齐栈指针。
2. 切换栈（在某种情况下）：CPU特权等级发生改变的时候，栈会被切换，例如CPU 异常发生在用户态程序的时候。用所谓的中断栈表（ Interrupt Stack Table , 下篇文章解释 ）配置特定中断的栈切换也是可行的。
3. 压入原来的栈指针：在中断发生的时候（对齐栈指针发生之前），CPU将栈指针（rsp）和栈段（ss)寄存器压入栈中。如此一来，中断处理函数返回时就可以复原栈指针的原始值。
4. 压入并更新RFLAGS寄存器：RFLAGS寄存器保存了多种控制和状态位。进入中断函数时，CPU修改一些位并压入旧的值。
5. 压入指令指针：跳转到中断处理函数之前，CPU压入指令指针（rip）和代码段（cs)。这类似于寻常的函数调用压入返回地址的过程。
6. 压入错误码（对于部分异常）：对于缺页错误等特定的异常，CPU会压入解释异常原因的错误码。
7. 调用中断处理函数：CPU从IDT对应的字段中读取中断处理函数的地址和段描述符。然后通过加载这些值到rip和cs寄存器中，调用中断处理函数。

### （六）双重异常

双重异常（double fault）是一个在CPU调用异常处理函数失败的时候触发的异常。通过处理双重异常，可以避免会引起系统复位的三重异常。为了彻底防止各种情况下的三重异常，需要建立中断栈表（ Interrupt Stack Table ）去捕获所有不同内核栈的双重异常。

保护页是存在栈底的特定内存页，它被用来发现栈溢出。保护页没有映射到任何物理内存页，所以访问它会导致缺页异常而不是无声无息地损坏其它内存。引导程序（bootloader）为内核栈建立了保护页，所以内核栈溢出会触发缺页异常。
当缺页异常发生，CPU查找IDT中地缺页异常处理函数并将中断栈帧（ interrupt stack frame）压入内核栈。然而，当前栈指针依然指向不可用地保护页。因此，第二个缺页异常被触发了，这会引发双重异常（根据上表）。
CPU 试图调用双重异常处理函数，它当然会试图压入异常栈帧。此时栈指针依然会指向保护页（因为栈溢出了），所以第三个缺页异常被触发了，紧接着三重异常和系统复位也发生了。当前的双重异常处理函数无法阻止这种情形下的三重异常。

双重异常由普通异常和错误码组成

内核栈溢出会触发缺页异常，x86_64 架构可以在异常发生时切换到预定义且已知良好的栈中。这个切换发生在硬件级别，所以它可以在CPU压入异常栈帧之前完成
切换机制基于中断栈表（Interrupt Stack Table ，IST）。IST由7个指向已知良好的栈的指针组成。
对于每一个异常处理器，我们可以通过对应 IDT entry 中的 stack_pointers字段在 IST 中找到一个栈。
GDT被用于两件事情：在内核空间和用户空间之间切换，加载TSS结构体。

全局描述符表被用于两件事情：在内核空间和用户空间之间切换，加载 TSS 结构体。

## （七）：硬件中断

中断为外部硬件设备提供了向CPU发送通知的方法。这样一来，内核就不必定期检查键盘上是否有新字符产生（这一过程称作「轮询」），而是由键盘在出现按键事件时通知内核。采用这种方法有两个好处：一是中断处理更高效，因为内核只需要在硬件触发中断后进行响应；二是响应时间更短，因为内核可以即时作出响应，而不是在下一次轮询中进行处理。

与异常不同的是，硬件中断是异步（Asynchronously）发生的。

pic8259包提供的主要抽象是 ChainedPics 结构，它表示我们上面看到的「主/从二级可编程中断控制器」布局。

## （八）：内存分页简介

虚拟存储器空间的块称为页面，物理地址空间的块称为帧。每个页面可以单独映射到一个帧，这样就可以跨越非连续的物理帧分割更大的内存区域。
分页使用称为页表的表结构来存储映射信息。
有一个名为invlpg的特殊CPU指令（“invalidate page”），用于从TLB中删除指定页面的转换规则，下次访问时这个转换规则将从页表中从新加载。通过重新设置CR3寄存器，假装进行一次地址空间转换，也可以完全刷新TLB。
记住在每个页表修改时也要同时刷新TLB，否则CPU可能会继续使用旧的转换规则，这可能导致不确定的错误，这些错误很难调试。

在x86上，该寄存器称为CR3。 在运行每个程序实例之前，操作系统要将指向正确页表的指针加载到该寄存器。

我们看到每个表索引由9位组成，这是因为每个表有2^9 = 512个条目。 最低的12位是4KiB页面中的偏移（2^12字节= 4KiB）。48到64位没用，这意味着x86_64实际上不是64位，因为它只支持48位地址。 有计划通过5级页表将地址大小扩展到57位，但是还没有支持此功能的处理器。

即使48到64位不被使用，也不能将它们设置为任意值。 相反，此范围内的所有位必须是第47位的副本，以保持地址的唯一性，并允许未来的扩展，如5级页表。 这称为符号扩展，因为它与二进制补码中的符号扩展非常相似。 如果地址未正确进行符号扩展，则CPU会抛出异常。

4级页表使得虚拟地址的转换变得昂贵，因为每次地址翻译需要4次内存访问。为了提高性能，x86_64架构将最后几个转换缓存在所谓的转译后备缓冲器（TLB）中。这允许在仍然某个地址翻译仍然在缓存中时跳过翻译。

记住在每个页表修改时也要同时刷新TLB，否则CPU可能会继续使用旧的转换规则，这可能导致不确定的错误，这些错误很难调试。

当分页处于活动状态时，无法直接访问物理内存，因为程序可以轻松地绕过内存保护并访问其他程序的内存。

## （九）：内存分页实现

访问页表帧：
对所有页表进行恒等映射、

以固定偏移量映射、
每当我们创建一个新的页表时我们都需要创建一个新的映射。 另外，它不允许访问其他地址空间的页表，这在创建新进程时很有用。

映射整个物理内存
这种方法的缺点是需要额外的页表来存储物理内存的映射。 这些页表需要存储在某个地方，因此它们会占用一部分物理内存，这在内存量较小的设备上可能会成为问题

临时映射
为了能够创建临时映射，只需要一个恒等映射的1级页表
使用临时映射访问任意页表帧的过程将是：
在恒等映射的第1级页表中搜索空闲条目。
将该条目映射到我们要访问的页表的物理帧。
通过映射到条目的虚拟页面访问目标帧。
将条目设置回未使用状态，从而删除临时映射。

递归页表
另一个有趣的方法是递归地映射页表。这种方法的思想是将4级页面表的某些条目映射到4级表本身。通过这样做，我们有效地保留了虚拟地址空间的一部分，并将所有当前和将来的页表帧映射到该空间。

递归分页是一种有趣的技术，它向我们展示了一个页表中的映射可以非常有用。
但是，它也有一些缺点：
+ 它占用大量虚拟内存（512GiB）。 在较大的 48 位地址空间中，这不是一个大问题，但它可能导致非最优的缓存行为。
+ 它仅允许轻松访问当前活动的地址空间。 通过更改递归项仍然可以访问其他地址空间，但是需要临时映射才能切换回去。
+ 它在很大程度上依赖于 x86 的页表格式，可能无法在其他体系结构上使用。

引导加载程序可以创建内核运行的页表和引导加载程序有权访问页表，因此它可以创建我们需要的任何映射。在当前的实现中，bootloader crate支持上述两种方法，并通过 cargo fratures 进行控制：
+ map_physical_memory 功能将整个物理内存映射到虚拟地址空间中的某个位置。因此，内核可以访问所有物理内存，并且可以遵循 “映射完整物理内存” 方法。
+ 借助 recursive_page_table 功能，引导加载程序将递归映射一个 4 级页面表的条目。这允许内核按照“递归页面表”部分中的描述访问页面表。

启用此功能后，引导加载程序会将完整的物理内存映射到一些未使用的虚拟地址范围。为了将虚拟地址范围传达给我们的内核，引导加载程序会传递一个引导信息结构。
bootloader crate定义了一个BootInfo 结构体，该结构包含传递给我们内核的所有信息。

+ memory_map 字段包含可用物理内存的概述。这告诉我们内核系统中有多少可用物理内存，以及哪些内存区域为 VGA 硬件等设备保留。内存映射可以从 BIOS 或 UEFI 固件中查询，但是只能在启动过程中的早期进行查询。出于这个原因，它必须由引导加载程序提供，因为内核无法在之后获取它。在本文的后面，我们将需要内存映射。
+ physical_memory_offset 告诉我们物理内存映射的虚拟起始地址。通过将此偏移量添加到物理地址，我们可以获得相应的虚拟地址。这使我们可以从内核访问任意物理内存。

## （十）分配堆内存

堆通过两个称为allocate和deallocate函数在运行时支持动态内存分配。allocate函数返回指定大小的可用内存块，可用于存储变量。 然后，该变量将一直存在，直到通过调用对该变量的引用的deallocate函数将其deallocate为止。
#[global_allocator]属性告诉Rust编译器应该使用哪个分配器实例作为全局堆分配器。请注意，#[global_allocator]模块不能在子模块中使用，因此我们需要将其放入lib.rs。
#[alloc_error_handler]属性的来源。它指定发生分配错误时调用的函数，类似于在发生panic时调用panic处理程序的方式 
这个extern crate语句的作用 启用某个库
no_std应用程序的一个简单分配器箱是linked_list_allocator箱子

## （十一）内存分配器设计

分配器的职责是管理可用的堆内存。它需要在alloc调用中返回未使用的内存，并跟踪由dealloc释放的内存，以便可以再次重用它。最重要的是，它绝不能重复分配已经在其他地方使用的内存，因为这会导致不确定的行为。

### Bump分配器
最简单的分配器设计是Bump分配器。它线性分配内存，并且仅记录分配的字节数和分配次数。它仅在非常特定的用例中有用，因为它有一个严格的限制：它只能一次释放所有内存。Bump分配器背后的思想是通过增加（ “Bump” ） next变量来线性分配内存，该变量指向未使用的内存的开头。一开始，next等于堆的起始地址。每次分配时，next都会增加，因此它始终指向已用和未用内存之间的边界：
next指针单向移动，因此永远不会两次分配相同的存储区域。 当next到达堆末尾时，无法再分配更多的内存，从而导致下一次分配出现内存不足错误。

Bump分配器通常带有一个分配计数器，分配计数器在每个alloc调用中增加1，在每个dealloc调用中减少1。 当分配计数器达到零时，表示堆上分配的所有内存都已释放。在这种情况下，可以将next指针重置为堆的起始地址，以便完整的堆内存可再次用于分配。

在实现分配器时，跟踪任意数量的空闲内存区域的常见技巧是将这些区域本身用作后备存储。 这利用了以下事实：区域仍被映射到虚拟地址并由物理帧支持，但是不再需要存储信息。 通过在已被释放的区域中存储有关的信息，我们可以跟踪无限制数量的已被释放的区域，而无需额外的内存。

+ 最常见的实现方法是在释放的内存中构造一个链表，每个节点都是一个释放的内存区域。每个列表节点包含两个字段：内存区域的大小和指向下一个未使用的内存区域的指针。 使用这种方法，我们只需要一个指向第一个未使用区域（称为head ）的指针即可跟踪所有未使用区域，而与它们的数量无关。 产生的数据结构通常称为空闲列表 。

固定大小的块分配器设计也有很多变体。slab分配器和伙伴分配器是两个流行的示例，它们也用在诸如Linux之类的流行内核中。下面，我们对这两种设计进行简短介绍。

**slab分配器**

slab分配器的思想是使用与内核中选定类型直接对应的块大小。这样，那些类型的分配恰好适合块大小，并且不会浪费内存。有时，甚至有可能在未使用的块中预先初始化好类型实例，以进一步提高性能。

slab分配通常与其他分配器结合使用。例如，它可以与固定大小的块分配器一起使用，以进一步拆分分配的块，以减少内存浪费。它还经常用于在一次分配大块内存，然后在这块内存上实现对象池模式。

**伙伴分配器**

伙伴分配器设计不是使用链表来管理释放的块，而是使用二叉树数据结构以及2的幂次方块大小。当需要一定大小的新块时，它将一个较大的块分成两半，从而在树中创建两个子节点。每当再次释放一个块时，就会分析树中的相邻块。如果邻居也是空的，则将两个块重新连接在一起，成为一个大小两倍的块。

此合并过程的优点是减少了外部碎片，因此可以将较小的释放块重新用于较大的分配。它还不使用后备分配器，因此性能更可预测。最大的缺点是只能使用2的幂次的块大小，这可能会由于内部碎片而导致大量的内存浪费。因此，伙伴分配器通常与slab分配器结合使用，以将分配的块进一步拆分为多个较小的块。

### 总结

这篇文章概述了不同的分配器设计。我们学习了如何实现基本的Bump分配器，该分配器通过增加单个next指针来线性分配内存。虽然Bump分配非常快，但是只有释放所有分配后，它才能重新使用内存。因此，它很少用作全局分配器。

接下来，我们创建了一个链表分配器，该分配器使用空闲的内存块本身来创建链表，即所谓的链表。该列表可以存储任意数量的大小不同的已释放块。尽管不会发生内存浪费，但是由于分配请求可能需要完整遍历列表，因此该方法的性能很差。我们的实现还遭受外部碎片的困扰，因为它不会将相邻的释放块重新合并在一起。

为了解决链表方法的性能问题，我们创建了一个固定大小块分配器，该分配器预定义了一组固定的块大小。对于每个块大小，都存在一个单独的空闲列表，因此分配和取消分配只需要在列表的开头插入/弹出，因此非常快。由于每个分配都向上舍入到下一个更大的块大小，因此由于内部碎片而浪费了一些内存。

还有更多具有不同权衡取舍的分配器设计。slab分配可以很好地优化常见固定大小结构的分配，但并非在所有情况下都适用。伙伴分配使用二叉树将释放的块合并回去，但浪费了大量内存，因为它仅支持2次幂的块大小。同样重要的是要记住，每个内核实现都有独特的工作负载，因此没有适合所有情况的“最佳”分配器设计。

## (十二)Async/Await

多任务处理有两种形式：协作多任务处理要求任务定期放弃对CPU的控制，以便其他任务可以取得进展。抢占式多任务使用操作系统功能通过在任意时间点强行暂停线程切换线程。

抢占式多任务处理的思想是操作系统控制何时切换任务。为此，它利用了它在每个中断上重新获得对CPU的控制这一事实。这样，只要系统有新输入可用，就可以切换任务。操作系统还可以通过配置硬件计时器在该时间之后发送中断来确定允许任务运行的确切时间。

任务在任意时间点都可能被中断，此时它们可能正在进行某些计算。 为了能够在以后继续进行运算，操作系统必须备份任务的整个状态，包括其调用堆栈和所有CPU寄存器的值。 此过程称为上下文切换 。

在Rust中，Future由Future trait表示，如下所示：

``` Rust
pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}
```
关联类型 Output指定异步值的类型。
poll方法允许检查该值是否已可用。 它返回一个Poll枚举，如下所示：
``` Rust
pub enum Poll<T> {
    Ready(T),
    Pending,
}
```
当该值已经可用时，将其包装在Ready中返回。 否则，将返回Pending，它告知调用方该值尚不可用。

堆分配的值大多数时候已经具有固定的内存地址。它们是调用allocate创建的，然后由指针类型（如Box）引用。虽然可以移动指针类型，但指针指向的堆值将保持在相同的内存地址，直到deallocate再次通过调用将其释放为止。

Unpin trait是一个自动trait，对于除明确选择不实现的类型之外，所有类型均自动实现了Unpin。只要自引用结构明确选择不实现Unpin，就没有（safe的）方法可以从Pin<Box<T>>类型获取&mut T。 这样做的结果就是保证了它们的内部自引用保持有效。

我们选择强制不实现Unpin，方法是添加类型为PhantomPinned的一个字段。此类型是大小为零的标记类型，其唯一目的是不实现Unpin特征。由于auto trait的工作方式，单个不Unpin的字段也会使得整个struct Unpin。

该get_unchecked_mut(它是unsafe的)函数在 Pin<&mut T>工作，而不是在Pin<Box<T>>上，因此我们必须先使用Pin::as_mut转换值

Executor的目的是允许将Future作为独立的任务生成，通常通过某种spawn方法。然后，Executor负责轮询所有Future，直到完成为止。中心化管理所有Future的最大优势在于，每当Future返回Poll::Pending时，Executor就可以切换到另一个Future。因此，异步操作可以并行运行，并且CPU保持繁忙。

Waker API背后的想法是，将特殊的Waker类型变量传递给包装在该Context类型中的每次poll调用。此Waker类型变量由Executor创建，并且异步任务可以用它来表示其（部分）完成。这样Executor在相应的Waker通知它之前，就不再需要不断在先前返回了Poll::Pending的future上调用poll了。

从async/await创建的Future实例通常是自引用的。通过将Self包装入Pin并让编译器让async/await创建的含有自我指涉的Future不自动实现Unpin，它保证了Future在多次调用之间未在内存之间移动。这样可以确保所有内部引用仍然有效。

在第一个poll调用之前移动Future是可以的。这是由于Future是懒惰的，在第一次被poll之前什么都不做。因此生成的状态机的start状态，只包含了函数的参数，而不会有内部引用。为了调用poll，调用者必须先将future包装到Pin，以确保future无法再在内存中移动。由于栈上的固定很难正确完成，因此我建议为此始终使用结合Box::pin和Pin::as_mut的方式。

如果你有兴趣了解如何使用栈上固定安全地实现Future的组合子函数，可以看看futurescrate中相对较短

OnceCell类型的优点是我们可以确保初始化不会在中断处理程序中发生，从而防止了在中断处理程序中执行堆分配。

Context: 异步任务的上下文。目前，`Context`仅用于提供对可用于唤醒当前任务的`&Waker`的访问。

该RawWaker类型要求程序员明确定义一个虚函数表（vtable），该表指定了在RawWaker克隆，唤醒或删除它们时应调用的函数。此vtable的布局由RawWakerVTable类型定义。每个函数接收一个\*const ()参数，该参数基本上是指向某个结构的类型被擦除掉的 &self指针，例如，堆上的内存分配。使用\*const ()指针而不是适当的引用的原因是该RawWaker类型应该是非泛型的，但仍支持任意类型。传递给函数的指针值是RawWaker::new中传入的data指针值。

通常，RawWaker为包裹在Box或Arc类型中的一些堆分配的结构创建。对于此类类型，可以使用诸如Box::into_raw之类的方法将Box<T>转换为\*const T指针。然后，可以将该指针转换为匿名\*const ()指针并传递给RawWaker::new。由于每个vtable函数接收同样的的*const ()参数，因此这些函数可以安全地将指针强制转换回Box<T>或 &T进行操作。可以想象，此过程非常危险，很容易导致错误的不确定行为。因此，除非必要，否则不建议手动创建RawWaker。

OnceCell类型的优点是我们可以确保初始化不会在中断处理程序中发生，从而防止了在中断处理程序中执行堆分配。

空闲时睡眠
基本思想是在task_queue和wake_queue都为空时执行hlt指令。该指令使CPU进入睡眠状态，直到下一个中断到来。CPU立即在中断后再次变为活动状态，这确保了当中断处理程序向wake_queue推送时，我们仍然可以直接做出反应。

Stream
+ 关联的类型名为Item而不是Output。
+ 代替返回Poll<Self::Item>的poll方法，Stream trait定义了poll_next方法，该方法返回一个Poll<Option<Self::Item>>（注意多出来的Option）。

## 注：Rustup — Rust的版本管理器

Rustup工具已成为推荐的安装Rust的方式，并在我们的网站上有。它的功能远不止于此，允许您管理各种版本，组件和平台。

安装 Rust 的其他版本，执行 rustup install：

`rustup install 1.30.0`
对每夜版也是有效的：

`rustup install nightly-2018-08-01`
三种最新的版本:
```
rustup install stable
rustup install beta
rustup install nightly
```
### 升级
升级所有安装的版本，你可以执行：


`rustup update`
这将查看您已安装的所有内容，如果有新版本，将会更新。

### 版本管理

查看已安装的版本
rustup toolchain list

设置非 stable 的为默认版本：

`rustup toolchain default nightly`
使用一个 toolchain 而不是默认的，rustup run：

`rustup run nightly cargo build`
还有一个别名，这个更短一些：
`cargo +nightly build`
如果您希望每个目录具有不同的默认值，那也很容易！ 如果你在项目中运行它：
`rustup override set nightly`
然后当你在那个目录中时，rustc 或 cargo 的任何调用都将使用该工具链。 要与其他人共享，可以使用工具链的内容创建一个 rust-toolchain 文件，并将其检入源代码管理中。 现在，当有人克隆您的项目时，他们将获得正确的版本，而无需自己“覆盖集合”。
### 安装其他目标 (target)

Rust 支持交叉编译到其他平台，Rustup 可以帮助您管理它们。 例如，要使用 MUSL：
`rustup target add x86_64-unknown-linux-musl`
然后，你可以：
`cargo build --target=x86_64-unknown-linux-musl`
查看所有安装的目标：
`rustup target list`
### 安装组件
组件用于安装某些类型的工具。虽然大多数工具都提供了“cargo-install”，但有些工具需要深入集成到编译器中。 Rustup 确切地知道您正在使用的编译器版本，因此它只具有这些工具所需的信息。
组件是每个工具链，因此如果您希望它们可用于多个工具链，则需要多次安装它们。 在下面的示例中，添加一个 --toolchain 标志，设置为您要安装的工具链，例如 nightly。 如果没有此标志，它将安装默认工具链的组件。
要查看可以安装的完整组件列表：
`rustup component list`
接下来，让我们谈谈一些流行的组件以及何时需要安装它们。
rust-docs, 本地文档
安装工具链时，默认情况下会安装此第一个组件。 它包含Rust的文档副本，以便您可以脱机阅读。
rust-src 标准库代码的拷贝
rust-src 组件可以为您提供 Rust 的源代码的本地副本。你为什么需要这个？好吧，像 Racer 这样的自动完成工具使用这些信息来了解你要调用的函数的更多信息。
`rustup component add rust-src`

### “预览”组件

“预览”阶段有几个组件。这些组件的名称目前都有-preview，这表明它们还没有100％准备好进行一般使用。请尝试一下并给我们反馈，但要知道他们不遵循 Rust 的稳定性保证，并且仍然在积极地改变，可能是以向后不兼容的方式。
rustfmt-preview 自动代码格式化
如果您希望自动格式化代码，可以安装此组件：
`rustup component add rustfmt-preview`
这将安装两个工具，rustfmt 和 cargo-fmt，它们将为您自动格式化代码！ 例如：
`cargo fmt` 将重新格式化您的整个cargo项目。
rls-preview 为了 IDE 集成
许多IDE功能都是基于langserver协议 构建的。要使用这些 IDE 获得对 Rust 的支持，您需要安装 Rust 语言服务器，即“RLS”：
`rustup component add rls-preview`
你的IDE应该从那拿到它。

clippy-preview 更多的 lints
要获得更多的 lints 来帮助你编写 Rust 代码，你可以安装 clippy：
`rustup component add clippy-preview`
This will install cargo-clippy for you:
`cargo clippy`
更多信息，查阅 [clippy's documentation](https://github.com/rust-lang-nursery/rust-clippy).
llvm-tools-preview 使用额外的LLVM工具
如果您想使用 lld 链接器或其他工具，如 llvm-objdump 或 llvm-objcopy，您可以安装此组件：
`rustup component add llvm-tools-preview`
这是最新的组件，因此目前没有良好的文档。

cargo xtest --target x86_64-yan_os.json
cargo xbuild --target x86_64-yan_os.json
cargo xrun --target x86_64-yan_os.json

## 总结整理
### 使用第三方包

1. 在Cargo.toml中的[dependencies]下加入包的依赖；
2. 在需要引入的文件头部加入 extern crate 包名; 之后才可以use 包（Rust 2015）。在2018中，直接可以用use xxx。
Note：Cargo默认把连字符替换为下划线。